# c++语法

## 初识c++

### 编译环境

​	g++ 后缀.cpp

### 命名空间(namespace)

​	为了解决合作开发是命名冲突问题

```c++
namespace name {
 	variables, funtions, classes   
}
```

使用命名空间中的：

​	name::variables

解析命名空间:

​	using namespace name;

​	std标准命名空间

​	最近标准：头文件去掉.h c的头文件，cstdio

### 输入输出

​	cin / cout 

### c++函数

​	默认参数，但是必须在后面

### c++函数重载

1. 多个函数拥有相同的名字，但是参数列表不同(参数类型、参数的顺序、参数的个数)

- 规则：	
  - 函数名必须相同
  - 参数列表必须不同
  - 函数的返回值无所谓，可以相同也可以不同
  - 仅仅是返回值类型不同不叫重载

### 类和对象

1. 类(class)c中结构体升级，由成员变量和成员函数组成 抽象

2. 通过类定义出来的变量---》对象（object）实例

   ```c++
   class Classname{
       public: // 共有的在类的内部和外部都能访问和修改的
       	char *name;
       	void show();
       	// 构造方法
       	Classname(char *name, int age);
       private: // 只有在类的内部可以访问和修改的 
      		int age;
   };
   // 实现成员函数	::域解析符
   void Classname::show()
   {
   }
   // 实例化对象:自动调用构造方法
   Classname c; // 栈
   Classname *p = new Classname; // 堆 delete删除
   ```

3. 构造方法：(constructor)

   - 不管是声明还是定义，函数名字前都不能有返回值类型，void也不行

   - 不要出现return

   - 构造方法调用是强制性的，一旦类的内部定义了构造方法，则自动调用所创建的

     如果有多个重载的构造方法，那么创建对象时候根据所提供实参，选择与之匹配的那一个.

     如果没有写构造方法，则编译器自动生成一个。

4. 初始化列表

   - 为类的成员变量一一赋值，可以用一种特殊的形式---->初始化列表

   - ```c++
     Classname::Classname(char *n, int a) : name(n), age(a){}
     ```

5. 析构方法:(destructor)

   - 对象销毁的时候自动调用

   - ```
     ~Classname()
     ```

### c和c++区别:

#### 	const关键字

- 在c中const 修饰的变量交只读变量，但可以通过指针改变其值
- 在c++const修饰的变量不能改变，地址也不可以
- 在c++中修饰函数，只能访问常成员变量
- 在c++中修饰对象,常对象，只能调用const成员

#### 	static关键字

- c
  - 修饰全局变量和函数，限制作用域在本文件
  - 修饰局部变量称局部静态变量，延长声明周期，进程结束后才空间释放.之初始化一次
- c++
  - 静态成员变量,多个对象用的是同一个变量 初始化type Classname::var = 0,在类外进行
  - 修饰成员函数，称静态成员函数.没有this执政，只能访问静态成员

### this指针

​	编译器添加的，指向就是当前对象，不显示呈现在函数参数上

​	构造方法的参数列表初始化不能用this

### 成员对象和封闭类

1. 一个类的成员变量是另一个类的对象，称成员对象，包含成员对象的类叫封闭类
2. 初始化成员对象时只能通过初始化列表的形式

## 继承与派生

### 什么是继承和派生

1. 继承是一个类从另一个类获取成员变量和成员函数的过程。

2. 派生和继承是一个概念：被继承的类称为基类或父类，继承的类称为子类或派生类

3. 优势：
   - 当创建与现有类相似，使用继承可以减少代码量
   - 当拥有多个类时，他们有相似的成员变量和成员函数时，可以提取出来一个基类

### 三种继承方式:

​	public private protected

1. public继承
   - 基类中的所有public成员都能在派生类中为public属性
   - 基类中的所有protected成员在派生类中为protected属性
   - 基类中的所有private成员在派生类中不能使用
2. protected继承
   - 基类中的所有的public成员在派生类中为protected属性
   - 基类中的所有protected成员在派生类中为protected属性
   - 基类中所有private成员在派生类中不能使用
3. private继承
   - 基类中的所有public成员在派生类类为private属性
   - 基类中所有protected成员在派生类中为private属性
   - 基类中所有的private成员在派生类中不能使用

### 基类和派生类构造方法

- 派生类不会继承基类的构造函数

- 但是派生类中继承来的成员变量有需要基类的构造函数完成

- 在派生类中的构造函数中调用基类的构造函数--->通过参数列表的形式调用

- 明确构造函数的调用顺序

  - 派生类的构造函数只能调用直接基类的构造函数

- 基类构造函数的调用规则

  - 派生类创建对象的时候必须要调用基类的构造函数。如果不显示调用，就调用基类

    默认的构造函数

### 基类和派生类中析构函数

- 析构方法也是不继承
- 在派生类中的析构函数不用显示的调用
- 析构函数的执行顺序与构造函数相反，先执行派生类的析构函数，在执行基类的析构函数

### 多继承

- 一个派生类可以有两个或多个基类---》多继承

- 不推荐大范围使用，使得代码逻辑复杂

- 问题：命名冲突---》菱形继承
- 虚继承---》virtual 在派生类中值保留一份间接基类的成员
- 如果使用虚继承那么同意共享基类，被共享的基类称虚基类
- 虚继承构造函数调用规则：虚基类一般都是间接基类，派生类中的构造函数需要调用虚基类的构造函数(间接基类)

### c++向上转型

- 类就是一种数据类型，可以允许类型转换的，但是自存在与基类和派生类之间，只能派生类赋值给基类
- 赋值的本质将派生类对象的成员变量赋值给基类的成员变量，成员函数不存在赋值l

## 作业：

### 作业2020.06.08

1. 定义一个VLA(变长数组)类, 成员变量 :m_len, m_arr,通过所定义的边长数组类，实例化一个对象，此

   对象用于存放从标准输入读入的若干整型，并从小到大排序

### 作业2020.06.08

1. 定义一个学生类(名字，年龄，show方法)和一个地址类(省份，城市，区， show)

### 作业2020.06.11

1. 定义一个基类Accout,成员包含string类变量的m_userName用于保存账户拥有者姓名，

   函数包含默认构造函数和带参数构造函数用户初始化账户名，包含一个成员函数printName()

   派生类CreditAccout,增加整型数据成员credit用户记录该用户行用度，成员函数包含构造方法和

   printInfo(),要求printInfo()打印该用户的名字和信用度

2. 创建基类Building,用于存储一座楼房的层数、房间号、总平方数，建立派生类House,存储卧室数量，

   另外建立派生类Office，存储灭火器和电话的数量,要求所有类都有一个print()函数,分别打印成员变量的值